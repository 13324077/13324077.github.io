---
layout: post
title: STM32 GPIO模式介绍
date: 2018-01-04 22:46:16 +08:00
category:
    - hardware
keywords:
tags:
    - hardware
---


对于STM32 GPIO口有如下8种工作模式

- 输入浮空

- 输入上拉

- 输入下拉

- 模拟输入

- 开漏输出

- 推挽式输出

- 推挽式复用功能

- 开漏复用功能

每个I/O端口位可以自由编程，然而必须按照32位字访问I/O端口寄存器(不允许半字或字节访问)。 GPIOx_BSRR和GPIOx_BRR寄存器允许对任何GPIO寄存器进行读/更改的独立访问；这样，在读和更改访问之间产生IRQ时不会发生危险。

以下分别进行介绍

# 输入模式

## 浮空输入

![floating_input](/images/hardware/stm32_GPIO/floating_input.png)

上图红色的表示便是浮空输入的过程，

- 外部输入时0读出的就是0，

- 外部输入时1读出的就是1，

- 外部没有输入IO处于阻塞读不出电平状态。

**用处**：感觉在信号处理方面用的比较好，比如在读取一段一段的波形，可以清晰的知道什么时候是0信号，什么时候是1信号，什么时候是没有信号的。

**类比**：51单片机找不到类似的输入模式

## 上拉输入

![up_input](/images/hardware/stm32_GPIO/up_input.png)

上拉输入和浮空输入的区别是，上拉电阻的开关关闭了，如上图所示。IO没有输入的时候，IO电平等于VDD即1电平，当然IO输入低电平的事就是VDD和IO口形成一个闭环电路，根据分压法IO口出分担的电压为0。当然IO输入为1时，IO口电压和VDD相等，上拉电阻好比断开了，IO口的电压还是0。

**用处**：在按键使用的时候特别适用，按键的一端接地，一端接IO口，当按键没有按下的时候电平为高电平，当按键按下的时候IO是低电平。

**类比**：51单片机P1,P2,P3口就是上拉输入的，大家可以回忆一下51单片机的按键操作，我们应该知道51单片机除了P0口内部没有上拉电阻其他的IO都有上拉电阻。大家应该明白了51单片机没有按键的时候，我们读到的事高电平了吧！！

**总结**：上拉输入，不管输入1还是不输入IO的电平都是1，输入0是IO口的电平是0

**PS 按键是共地还是共VCC选择的时候要慎重**

## 下拉输入

![down_input](/images/hardware/stm32_GPIO/down_input.png)

下拉输入和上拉输入的区别是，上拉电阻的开关打开了了，下拉电阻的开关关闭；了。如上图所示。IO没有输入的时候，IO电平等于VSS即0电平，当IO输入高电平的时候IO口就和VSS组成一个闭合电路，根据分压法，电压都分担到了电阻上，所以IO口电平为高电平。当然IO输入为低电平的时候，IO口肯定是低电平。

**用处**：在按键使用的时候特别适用，按键的一端接VCC，一端接IO口，当按键没有按下的时候电平为低电平，当按键按下的时候IO是高电平电平。

**类比**：51单片机没有类似的IO口

**PS按键是共地还是共VCC选择的时候要慎重**

## 模拟输入

![analog_input](/images/hardware/stm32_GPIO/analog_input.png)

模拟输入，大家看上图的红色的标示。模拟输入和其他输入最大的区别

- 没有连接TTL触发器，这样保留最原始的电压值，不是转换过后的0和1信号

- 数据连接的终点不一样，其他的输入我们都是读取输入寄存器的值，而模拟输入，数据直接送到片上外设，一般是**ADC**。

# 输出模式

## 推挽式输出

![pp_output](/images/hardware/stm32_GPIO/pp_output.png)

上图就是就是推挽输出的过程。上图标示的“2”便是我们的输出寄存器，我们可以写入1或者0，

- 如果写入1，图上的“3”上面的P-mos导通，N-mos截止，IO口等价直接连接在VDD上，所以IO口电平是高电平。

- 同理输出寄存器的值为0时，P-mos截止，N-mos导通。IO口直接连接在VSS上，所有IO口电平为低电平。

大家可能会问图上标的1是什么？其实1的寄存器就是间接向输出寄存器写入。好处是有的，大家自己百度哈！！

**用处**：适合做一些开关控制，应为推挽输出可以快速的切换0和1，例如继电器，led等

**类比**：51单片机没有类似的IO口

## 开漏输出

![od_output](/images/hardware/stm32_GPIO/od_output.png)

上图红色标示便是开漏输出的过程图，图上1和2的标示已经在推挽输出中介绍了，此处不再说明。开漏输出与推挽输出唯一的区别就是开漏输出 **只有一个N-mos管**。

- 当输出寄存器的值为0的时候，n-mos导通，IO口直接连接VSS，输出为低电平。

- 当输出寄存器为1的时候，n-mos截止，IO口直接和输出端断开了，处于浮空状态。电平状态不可控制。

大家可能会说，这样设计不是傻缺么？有什么用设计这种输出方式。其实这种方式很有用的，请看下面的类比

**类比**：

我们都知道51单片机PO口，是不是想到什么了?对PO口就是类似的开漏输出， PO口作为输出的时候一定要加上拉电阻，加上上拉电阻后，输入寄存器为1的时候，n-mos截止截止了，好比IO和输出端断开，这时IO口电压就等于上拉电阻的电压。这样便输出了高电平，如果IO口的高电平，连接到了外设低电平的，就会产生电流，电流不会流到IO口，（N-mos管截止了）直接流到外设。是不是增大了驱动能力了。（IO口的驱动能力有限，不能容忍大电流）。

**通过改变上拉电阻的大小和电压就能完成很多功能**。

## 复用（推挽和开漏）输出

![af_output](/images/hardware/stm32_GPIO/af_output.png)

**复用推挽\开漏** 和 **推挽\开漏输出** 区别在于起点不一样，复用输出来源片上外设，比如IIC，SPI等。相信大家已经可以理解了，不做解释了。


# 参考

- [STM32GPIO口8种模式细致分析（类比51单片机）](http://blog.csdn.net/xg_2013/article/details/51325155)

- STM32中文参考手册2010 - 8. 通用和复用功能I/O(GPIO和AFIO)
